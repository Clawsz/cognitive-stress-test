<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Emoji Time Attack</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000000;
      color: #ffffff;
    }

    .container {
      width: 100%;
      max-width: 420px;
      padding: 16px 12px 22px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .top-bar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      text-align: center;
      font-size: 12px;
      letter-spacing: 0.04em;
    }

    .stat-label {
      color: #e5e7eb;
      opacity: 0.9;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 600;
      color: #ffffff;
    }

    .board-wrapper {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .board {
      position: relative;
      background: #ffffff;
      border-radius: 10px;
      padding: 10px;
      width: 100%;
      max-width: 360px;
      aspect-ratio: 1 / 1;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      overflow: hidden;
    }

    .grid {
      position: absolute;
      inset: 10px;
      display: grid;
      gap: 4px;
    }

    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f3f4f6;
      border-radius: 6px;
      font-size: min(7.5vw, 30px);
      cursor: pointer;
      user-select: none;
      transition: transform 0.06s ease, box-shadow 0.06s ease, background 0.15s ease, opacity 0.15s ease;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.18);
    }

    .cell:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(15, 23, 42, 0.22);
      background: #e5e7eb;
    }

    .cell:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.3);
    }

    .cell.correct-flash {
      background: #dcfce7 !important;
    }

    .cell.wrong-flash {
      background: #fee2e2 !important;
    }

    .cell.cleared {
      background: transparent !important;
      box-shadow: none !important;
      opacity: 0;
      cursor: default;
    }

    .footer-note {
      margin-top: 8px;
      font-size: 11px;
      color: #9ca3af;
      text-align: center;
    }

    .target-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90px;
      height: 90px;
      border-radius: 18px;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .target-emoji {
      font-size: 40px;
    }

    .bottom-bar {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 32px;
      margin-top: 4px;
    }

    .pill-label {
      padding: 8px 22px;
      border-radius: 999px;
      border: 1.5px solid #ffffff;
      background: transparent;
      color: #ffffff;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.03em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .icon-btn {
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1.5px solid #ffffff;
      background: transparent;
      color: #ffffff;
      font-size: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .icon-btn:active {
      transform: translateY(1px);
    }

    @media (max-width: 480px) {
      .container {
        padding: 12px 10px 18px;
      }
      .stat-value {
        font-size: 14px;
      }
      .target-overlay {
        width: 80px;
        height: 80px;
      }
      .target-emoji {
        font-size: 34px;
      }
    }
  
  /* Make center target non-clickable */
  #target, #center, .target { pointer-events: none !important; }

  #target, #center, .target { cursor: default !important; }
</style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div class="stat">
        <div class="stat-label">Record</div>
        <div class="stat-value" id="bestDisplay">â€“</div>
      </div>
      <div class="stat">
        <div class="stat-label">Time Left</div>
        <div class="stat-value" id="timeDisplay">60.000</div>
      </div>
      <div class="stat">
        <div class="stat-label">Errors</div>
        <div class="stat-value" id="errorDisplay">0</div>
      </div>
    </div>

    <div class="board-wrapper">
      <div class="board">
        <div id="grid" class="grid"></div>
        <div class="target-overlay">
          <span id="targetEmoji" class="target-emoji">ðŸŽ¯</span>
        </div>
      </div>
    </div>

    <div class="bottom-bar">
      <div id="sizeLabel" class="pill-label">3 Ã— 3</div>
      <button id="restartBtn" class="icon-btn">âŸ³</button>
    </div>

    <div class="footer-note">
      Start with 60s. Each correct emoji gives +1.00s. Clear a board to gain +5s and level up from 3Ã—3 to 10Ã—10.
    </div>
  </div>

  <script>
    // Face vs non-face emoji pools
    const faceEmojis = [
      "ðŸ˜€","ðŸ˜ƒ","ðŸ˜„","ðŸ˜","ðŸ˜†","ðŸ˜…","ðŸ˜‚","ðŸ¤£",
      "ðŸ˜Š","ðŸ˜‡","ðŸ™‚","ðŸ™ƒ","ðŸ˜‰","ðŸ˜Œ","ðŸ˜","ðŸ¥°",
      "ðŸ˜˜","ðŸ˜—","ðŸ˜™","ðŸ˜š","ðŸ˜‹","ðŸ˜›","ðŸ˜","ðŸ˜œ",
      "ðŸ¤ª","ðŸ¤¨","ðŸ§","ðŸ¤“","ðŸ˜Ž","ðŸ¥³","ðŸ˜¤","ðŸ˜±"
    ];

    const otherEmojis = [
      "ðŸ‘»","ðŸ’€","ðŸ¤–","ðŸ‘½","ðŸ±","ðŸ¶","ðŸµ","ðŸ¸",
      "ðŸ§","ðŸ¼","ðŸ»","ðŸ¯","ðŸ¦Š","ðŸ¦","ðŸŒž","ðŸŒ™",
      "â­","âš¡","ðŸ”¥","ðŸ’§","ðŸ€","ðŸŽ","ðŸ•","ðŸ”",
      "ðŸŸ","ðŸ£","ðŸ©","ðŸª","ðŸŽ‚","ðŸ¿","âš½","ðŸ€",
      "ðŸŽ®","ðŸŽ²","ðŸŽ§","ðŸ“š","ðŸ’¡","ðŸ“Ž","ðŸ™","ðŸ³"
    ];

    const restartBtn    = document.getElementById("restartBtn");
    const gridElement   = document.getElementById("grid");
    const timeDisplay   = document.getElementById("timeDisplay");
    const bestDisplay   = document.getElementById("bestDisplay");
    const errorDisplay  = document.getElementById("errorDisplay");
    const targetEmojiEl = document.getElementById("targetEmoji");
    const sizeLabel     = document.getElementById("sizeLabel");

    const START_TIME_MS = 60000;
    const BONUS_TIME_MS = 5000;
    const PER_CLICK_BONUS_MS = 1000; // +1.00s per correct click
    const MIN_GRID = 3;
    const MAX_GRID = 10;

    let gridSize = MIN_GRID;
    let chosenEmojis = [];
    let sequenceOrder = [];
    let currentIndex = 0;

    let timeRemainingMs = START_TIME_MS;
    let timerInterval = null;
    let timerRunning = false;
    let lastTick = null;

    let finished = false;
    let bestSizeReached = 0;
    let errors = 0;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function formatSeconds(ms) {
      return (ms / 1000).toFixed(3);
    }

    function updateTimeDisplay() {
      timeDisplay.textContent = formatSeconds(Math.max(timeRemainingMs, 0));
    }

    function updateBestDisplay() {
      if (bestSizeReached < MIN_GRID) {
        bestDisplay.textContent = "â€“";
      } else {
        bestDisplay.textContent = bestSizeReached + "Ã—" + bestSizeReached;
      }
    }

    function startTimer() {
      if (timerRunning) return;
      timerRunning = true;
      lastTick = performance.now();

      timerInterval = setInterval(() => {
        if (!timerRunning) return;
        const now = performance.now();
        const delta = now - lastTick;
        lastTick = now;

        timeRemainingMs -= delta;
        if (timeRemainingMs <= 0) {
          timeRemainingMs = 0;
          updateTimeDisplay();
          gameOver();
        } else {
          updateTimeDisplay();
        }
      }, 30);
    }

    function stopTimer() {
      timerRunning = false;
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function gameOver() {
      finished = true;
      stopTimer();
      targetEmojiEl.textContent = "â›”";
    }

    function victory() {
      finished = true;
      stopTimer();
      targetEmojiEl.textContent = "ðŸ†";
    }

    function setTargetEmoji() {
      if (currentIndex >= sequenceOrder.length) {
        targetEmojiEl.textContent = "âœ…";
      } else {
        targetEmojiEl.textContent = sequenceOrder[currentIndex];
      }
    }

    // Build board with max 10 face emojis, rest non-face
    function buildEmojiSet() {
      const totalCells = gridSize * gridSize;
      const maxFaces = Math.min(10, totalCells);

      const facesCopy = shuffle([...faceEmojis]);
      const othersCopy = shuffle([...otherEmojis]);

      const selectedFaces = facesCopy.slice(0, maxFaces);
      const selectedOthers = othersCopy.slice(0, totalCells - maxFaces);

      return shuffle([...selectedFaces, ...selectedOthers]);
    }

    function setupBoardForCurrentSize() {
      chosenEmojis = buildEmojiSet();
      sequenceOrder = shuffle([...chosenEmojis]);
      currentIndex = 0;
      sizeLabel.textContent = gridSize + " Ã— " + gridSize;
      setTargetEmoji();
      renderGrid();
    }

    function advanceBoard() {
      // record best size
      if (gridSize > bestSizeReached) {
        bestSizeReached = gridSize;
        updateBestDisplay();
      }

      // last board cleared
      if (gridSize >= MAX_GRID) {
        victory();
        return;
      }

      // bonus time and next board
      timeRemainingMs += BONUS_TIME_MS;
      updateTimeDisplay();

      gridSize++;
      setupBoardForCurrentSize();
    }

    function handleCellClick(e) {
      if (finished) return;
      const cell = e.currentTarget;
      if (cell.classList.contains("cleared")) return;

      if (!timerRunning) {
        startTimer();
      }

      const emoji = cell.dataset.emoji;
      const expected = sequenceOrder[currentIndex];

      if (emoji === expected) {
        // +1.00s per correct click
        timeRemainingMs += PER_CLICK_BONUS_MS;
        updateTimeDisplay();
        cell.classList.add("correct-flash");
        setTimeout(() => {
          cell.classList.remove("correct-flash");
          cell.textContent = "";
          cell.classList.add("cleared");
        }, 80);

        currentIndex++;
        setTargetEmoji();

        if (currentIndex >= sequenceOrder.length) {
          advanceBoard();
        }
      } else {
        errors++;
        errorDisplay.textContent = String(errors);
        cell.classList.add("wrong-flash");
        setTimeout(() => cell.classList.remove("wrong-flash"), 120);
        if (navigator.vibrate) {
          navigator.vibrate(40);
        }
      }
    }

    function renderGrid() {
      gridElement.innerHTML = "";
      gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

      const layout = shuffle([...chosenEmojis]);
      layout.forEach(emoji => {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.textContent = emoji;
        cell.dataset.emoji = emoji;
        cell.addEventListener("click", handleCellClick);
        gridElement.appendChild(cell);
      });
    }

    function resetRun() {
      stopTimer();
      timeRemainingMs = START_TIME_MS;
      updateTimeDisplay();

      gridSize = MIN_GRID;
      errors = 0;
      errorDisplay.textContent = "0";

      finished = false;
      targetEmojiEl.textContent = "ðŸŽ¯";

      // keep bestSizeReached between runs or reset? keep as overall record
      updateBestDisplay();
      setupBoardForCurrentSize();
    }

    restartBtn.addEventListener("click", resetRun);

    // Initial run
    resetRun();
  </script>
</body>
</html>
